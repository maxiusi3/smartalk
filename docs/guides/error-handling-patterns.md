# SmarTalk é”™è¯¯å¤„ç†æ¨¡å¼æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰äº† SmarTalk é¡¹ç›®ä¸­ç»Ÿä¸€çš„é”™è¯¯å¤„ç†æ¨¡å¼å’Œæœ€ä½³å®è·µï¼Œç¡®ä¿å‰åç«¯é”™è¯¯å¤„ç†çš„ä¸€è‡´æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

## ğŸ¯ è®¾è®¡åŸåˆ™

### æ ¸å¿ƒåŸåˆ™
1. **ç»Ÿä¸€æ€§**: å‰åç«¯ä½¿ç”¨ä¸€è‡´çš„é”™è¯¯å¤„ç†æ¨¡å¼
2. **å¯è¿½è¸ªæ€§**: æ‰€æœ‰é”™è¯¯éƒ½åº”è¯¥å¯ä»¥è¿½è¸ªå’Œè°ƒè¯•
3. **ç”¨æˆ·å‹å¥½**: å‘ç”¨æˆ·å±•ç¤ºæ¸…æ™°ã€å¯æ“ä½œçš„é”™è¯¯ä¿¡æ¯
4. **å¯æ¢å¤æ€§**: æä¾›é”™è¯¯æ¢å¤æœºåˆ¶å’Œé‡è¯•ç­–ç•¥
5. **å¯ç›‘æ§æ€§**: æ”¯æŒé”™è¯¯ç›‘æ§å’Œå‘Šè­¦

### é”™è¯¯åˆ†ç±»
- **ç³»ç»Ÿé”™è¯¯**: æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ã€ç½‘ç»œé”™è¯¯ç­‰
- **ä¸šåŠ¡é”™è¯¯**: ä¸šåŠ¡é€»è¾‘éªŒè¯å¤±è´¥ã€æƒé™ä¸è¶³ç­‰
- **ç”¨æˆ·é”™è¯¯**: è¾“å…¥éªŒè¯å¤±è´¥ã€æ“ä½œä¸å½“ç­‰
- **å¤–éƒ¨é”™è¯¯**: ç¬¬ä¸‰æ–¹æœåŠ¡é”™è¯¯ã€ä¾èµ–æœåŠ¡ä¸å¯ç”¨ç­‰

## ğŸ—ï¸ é”™è¯¯å¤„ç†æ¶æ„

### æ•´ä½“æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å‰ç«¯/ç§»åŠ¨ç«¯   â”‚    â”‚     API ç½‘å…³    â”‚    â”‚     åç«¯æœåŠ¡    â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ é”™è¯¯è¾¹ç•Œ    â”‚ â”‚    â”‚ â”‚ é”™è¯¯ä¸­é—´ä»¶  â”‚ â”‚    â”‚ â”‚ é”™è¯¯å¤„ç†å™¨  â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ é”™è¯¯ç®¡ç†å™¨  â”‚ â”‚    â”‚ â”‚ å“åº”æ ¼å¼åŒ–  â”‚ â”‚    â”‚ â”‚ æ—¥å¿—è®°å½•    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   é”™è¯¯ç›‘æ§ç³»ç»Ÿ  â”‚
                    â”‚   (Sentryç­‰)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸš¨ åç«¯é”™è¯¯å¤„ç†

### é”™è¯¯å¤„ç†ä¸­é—´ä»¶
```typescript
// Express é”™è¯¯å¤„ç†ä¸­é—´ä»¶
import { globalErrorManager } from '@shared/utils/errorHandler';
import { handleApiError, getHttpStatusFromError } from '@shared/utils/apiResponse';

export const errorMiddleware = (error: any, req: any, res: any, next: any) => {
  // è®°å½•é”™è¯¯
  globalErrorManager.handleError(error, {
    requestId: req.id,
    userId: req.user?.id,
    url: req.originalUrl,
    method: req.method,
    userAgent: req.headers['user-agent'],
    ip: req.ip,
  });
  
  // æ ¼å¼åŒ–é”™è¯¯å“åº”
  const errorResponse = handleApiError(error, req.id);
  const statusCode = getHttpStatusFromError(errorResponse.error);
  
  res.status(statusCode).json(errorResponse);
};
```

### ä¸šåŠ¡é€»è¾‘é”™è¯¯å¤„ç†
```typescript
import { ApiError, ApiErrorCode } from '@shared/utils/apiResponse';

// æœåŠ¡å±‚é”™è¯¯å¤„ç†
export class UserService {
  async getUserById(id: string) {
    try {
      const user = await this.userRepository.findById(id);
      
      if (!user) {
        throw new ApiError(
          ApiErrorCode.USER_NOT_FOUND,
          `User not found with id: ${id}`,
          { userId: id }
        );
      }
      
      return user;
    } catch (error) {
      // é‡æ–°æŠ›å‡º API é”™è¯¯
      if (error instanceof ApiError) {
        throw error;
      }
      
      // åŒ…è£…æœªçŸ¥é”™è¯¯
      throw new ApiError(
        ApiErrorCode.UNKNOWN_ERROR,
        'Failed to get user',
        { originalError: error.message }
      );
    }
  }
}
```

### æ§åˆ¶å™¨é”™è¯¯å¤„ç†
```typescript
import { Request, Response, NextFunction } from 'express';
import { ApiResponses } from '@shared/utils/apiResponse';

export class UserController {
  async getUser(req: Request, res: Response, next: NextFunction) {
    try {
      const user = await this.userService.getUserById(req.params.id);
      res.json(ApiResponses.ok(user, req.id));
    } catch (error) {
      // ä¼ é€’ç»™é”™è¯¯ä¸­é—´ä»¶å¤„ç†
      next(error);
    }
  }
}
```

## ğŸ’» å‰ç«¯é”™è¯¯å¤„ç†

### React é”™è¯¯è¾¹ç•Œ
```typescript
import React from 'react';
import { handleClientError } from '@shared/utils/clientErrorHandler';

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends React.Component<
  React.PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: React.PropsWithChildren<{}>) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    handleClientError(error, {
      component: 'ErrorBoundary',
      action: 'component_error',
      additionalData: errorInfo,
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      );
    }
    
    return this.props.children;
  }
}
```

### API è°ƒç”¨é”™è¯¯å¤„ç†
```typescript
import { handleClientError } from '@shared/utils/clientErrorHandler';
import { isErrorResponse } from '@shared/utils/apiResponse';

export class ApiClient {
  async request<T>(url: string, options: RequestInit = {}): Promise<T> {
    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
      });
      
      const data = await response.json();
      
      if (isErrorResponse(data)) {
        await handleClientError(data, {
          component: 'ApiClient',
          action: 'api_request',
          url,
        });
        throw new Error(data.error.message);
      }
      
      return data.data;
    } catch (error) {
      if (error instanceof TypeError && error.message.includes('fetch')) {
        await handleClientError(error, {
          component: 'ApiClient',
          action: 'network_error',
          url,
        });
      }
      throw error;
    }
  }
}
```

### ç»„ä»¶çº§é”™è¯¯å¤„ç†
```typescript
import React, { useState, useEffect } from 'react';
import { handleClientError } from '@shared/utils/clientErrorHandler';

export const UserProfile: React.FC = () => {
  const [user, setUser] = useState(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const loadUser = async () => {
      try {
        setLoading(true);
        setError(null);
        
        const userData = await apiClient.getUser();
        setUser(userData);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to load user';
        setError(errorMessage);
        
        await handleClientError(err as Error, {
          component: 'UserProfile',
          action: 'load_user',
        });
      } finally {
        setLoading(false);
      }
    };
    
    loadUser();
  }, []);
  
  if (loading) return <div>Loading...</div>;
  
  if (error) {
    return (
      <div className="error-message">
        <p>{error}</p>
        <button onClick={() => window.location.reload()}>
          Retry
        </button>
      </div>
    );
  }
  
  return <div>{/* ç”¨æˆ·ä¿¡æ¯ */}</div>;
};
```

## ğŸ“± ç§»åŠ¨ç«¯é”™è¯¯å¤„ç†

### React Native é”™è¯¯è¾¹ç•Œ
```typescript
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { handleClientError } from '@shared/utils/clientErrorHandler';

export class MobileErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    handleClientError(error, {
      component: 'MobileErrorBoundary',
      action: 'component_error',
      platform: 'mobile',
      additionalData: errorInfo,
    });
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Something went wrong</Text>
          <TouchableOpacity
            style={styles.retryButton}
            onPress={() => this.setState({ hasError: false })}
          >
            <Text style={styles.retryText}>Try Again</Text>
          </TouchableOpacity>
        </View>
      );
    }
    
    return this.props.children;
  }
}
```

### ç½‘ç»œé”™è¯¯å¤„ç†
```typescript
import NetInfo from '@react-native-async-storage/async-storage';
import { handleClientError } from '@shared/utils/clientErrorHandler';

export class MobileApiClient {
  async request<T>(url: string, options: RequestInit = {}): Promise<T> {
    // æ£€æŸ¥ç½‘ç»œè¿æ¥
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected) {
      const error = new Error('No internet connection');
      await handleClientError(error, {
        component: 'MobileApiClient',
        action: 'network_check',
        additionalData: { netInfo },
      });
      throw error;
    }
    
    try {
      const response = await fetch(url, {
        ...options,
        timeout: 30000, // 30ç§’è¶…æ—¶
      });
      
      return await response.json();
    } catch (error) {
      await handleClientError(error, {
        component: 'MobileApiClient',
        action: 'api_request',
        url,
        platform: 'mobile',
      });
      throw error;
    }
  }
}
```

## ğŸ“Š é”™è¯¯ç›‘æ§å’Œåˆ†æ

### é”™è¯¯æŒ‡æ ‡
- **é”™è¯¯ç‡**: é”™è¯¯è¯·æ±‚æ•° / æ€»è¯·æ±‚æ•°
- **é”™è¯¯åˆ†å¸ƒ**: æŒ‰é”™è¯¯ç±»å‹ã€ç»„ä»¶ã€ç”¨æˆ·åˆ†ç»„
- **é”™è¯¯è¶‹åŠ¿**: é”™è¯¯æ•°é‡éšæ—¶é—´çš„å˜åŒ–
- **æ¢å¤æ—¶é—´**: ä»é”™è¯¯å‘ç”Ÿåˆ°è§£å†³çš„æ—¶é—´

### ç›‘æ§é…ç½®
```typescript
import { setupErrorHandling } from '@shared/utils/errorHandler';
import { setupClientErrorHandling } from '@shared/utils/clientErrorHandler';

// åç«¯é”™è¯¯ç›‘æ§
setupErrorHandling({
  enableSentry: true,
  sentryDsn: process.env.SENTRY_DSN,
  logFilePath: './logs/errors.log',
  enableGlobalHandlers: true,
});

// å‰ç«¯é”™è¯¯ç›‘æ§
setupClientErrorHandling({
  enableStorage: true,
  enableRemoteReporting: true,
  remoteEndpoint: '/api/v1/errors/report',
  userId: getCurrentUserId(),
  sessionId: getSessionId(),
});
```

## ğŸ”§ é”™è¯¯æ¢å¤ç­–ç•¥

### é‡è¯•æœºåˆ¶
```typescript
export class RetryableApiClient {
  async requestWithRetry<T>(
    url: string,
    options: RequestInit = {},
    maxRetries = 3
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await this.request<T>(url, options);
      } catch (error) {
        lastError = error;
        
        // ä¸é‡è¯•çš„é”™è¯¯ç±»å‹
        if (this.isNonRetryableError(error)) {
          throw error;
        }
        
        // æœ€åä¸€æ¬¡å°è¯•
        if (attempt === maxRetries) {
          throw error;
        }
        
        // æŒ‡æ•°é€€é¿
        const delay = Math.pow(2, attempt - 1) * 1000;
        await this.sleep(delay);
      }
    }
    
    throw lastError;
  }
  
  private isNonRetryableError(error: any): boolean {
    // 4xx é”™è¯¯é€šå¸¸ä¸åº”è¯¥é‡è¯•
    return error.status >= 400 && error.status < 500;
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### é™çº§ç­–ç•¥
```typescript
export class FallbackService {
  async getStoriesWithFallback(): Promise<Story[]> {
    try {
      // å°è¯•ä» API è·å–
      return await this.apiClient.getStories();
    } catch (error) {
      await handleClientError(error, {
        component: 'FallbackService',
        action: 'api_fallback',
      });
      
      // é™çº§åˆ°ç¼“å­˜æ•°æ®
      const cachedStories = await this.getCachedStories();
      if (cachedStories.length > 0) {
        return cachedStories;
      }
      
      // æœ€åé™çº§åˆ°é»˜è®¤æ•°æ®
      return this.getDefaultStories();
    }
  }
}
```

## âœ… æœ€ä½³å®è·µ

### é”™è¯¯å¤„ç†æ£€æŸ¥æ¸…å•
- [ ] æ‰€æœ‰ API è°ƒç”¨éƒ½æœ‰é”™è¯¯å¤„ç†
- [ ] é”™è¯¯ä¿¡æ¯å¯¹ç”¨æˆ·å‹å¥½
- [ ] æä¾›é”™è¯¯æ¢å¤æœºåˆ¶
- [ ] è®°å½•è¶³å¤Ÿçš„é”™è¯¯ä¸Šä¸‹æ–‡
- [ ] å®ç°é€‚å½“çš„é‡è¯•ç­–ç•¥
- [ ] é…ç½®é”™è¯¯ç›‘æ§å’Œå‘Šè­¦
- [ ] å®šæœŸå®¡æŸ¥é”™è¯¯æ—¥å¿—
- [ ] æµ‹è¯•é”™è¯¯åœºæ™¯

### ä»£ç è§„èŒƒ
1. **ç»Ÿä¸€é”™è¯¯ç±»å‹**: ä½¿ç”¨é¡¹ç›®å®šä¹‰çš„é”™è¯¯ç±»å‹
2. **å®Œæ•´é”™è¯¯ä¿¡æ¯**: åŒ…å«é”™è¯¯ç ã€æ¶ˆæ¯ã€ä¸Šä¸‹æ–‡
3. **é€‚å½“çš„é”™è¯¯çº§åˆ«**: æ ¹æ®é”™è¯¯ä¸¥é‡ç¨‹åº¦åˆ†ç±»
4. **é¿å…é”™è¯¯åå™¬**: ä¸è¦å¿½ç•¥æˆ–éšè—é”™è¯¯
5. **ç”¨æˆ·å‹å¥½æ¶ˆæ¯**: å‘ç”¨æˆ·å±•ç¤ºå¯ç†è§£çš„é”™è¯¯ä¿¡æ¯

### æ€§èƒ½è€ƒè™‘
- é¿å…åœ¨é”™è¯¯å¤„ç†ä¸­è¿›è¡Œé‡æ“ä½œ
- ä½¿ç”¨å¼‚æ­¥é”™è¯¯æŠ¥å‘Šé¿å…é˜»å¡
- é™åˆ¶é”™è¯¯æ—¥å¿—çš„å¤§å°å’Œæ•°é‡
- å®ç°é”™è¯¯å»é‡é¿å…é‡å¤æŠ¥å‘Š

---

**æ³¨æ„**: é”™è¯¯å¤„ç†æ˜¯ç³»ç»Ÿç¨³å®šæ€§çš„é‡è¦ä¿éšœï¼Œåº”è¯¥åœ¨å¼€å‘è¿‡ç¨‹ä¸­æŒç»­å®Œå–„å’Œä¼˜åŒ–ã€‚
